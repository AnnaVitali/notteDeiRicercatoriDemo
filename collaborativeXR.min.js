const e=new class{constructor(){this.listeners=[]}emit(e,t){this.listeners.filter((({name:t})=>t===e)).forEach((({callback:e})=>{setTimeout(e.apply(this,[t]),0)}))}on(e,t){"function"==typeof t&&"string"==typeof e&&this.listeners.push({name:e,callback:t})}off(e,t){this.listeners=this.listeners.filter((i=>!(i.name===e&&i.callback===t)))}destroy(){this.listeners.length=0}};export{e as eventBus};class t{constructor(e,t){if(p.verifyNameAlreadyExist(e))throw new Error("This name was already used!");this._name=e,this._time=t}get name(){return this._name}get time(){return this._time}setAnimationCallback(e){this.animationCallback=()=>{setTimeout(e.apply(this),0)},u.listenForInfrastructureEvent(this.name,this.animationCallback)}startAnimation(){w.update&&u.sendEvent("newAnimation",JSON.stringify(this))}stopAnimation(){w.update&&u.sendEvent("stopAnimation",JSON.stringify(this.name))}}export{t as Animation};class i{constructor(e,t){this._text=t,this._name=e}get name(){return this._name}get text(){return this._text}set text(e){this._text=e}setOnPointerDownCallback(e){u.listenForInfrastructureEvent(this.name,(()=>{w.update?setTimeout(e.apply(this),0):(w.update=!0,setTimeout(e.apply(this),0),w.update=!1)}))}}export{i as Button};class o{constructor(e){this._position=e}get position(){return this._position}}export{o as Menu};class s extends o{constructor(e,t){super(e),this._position=e,this._hologramName=t}get hologramName(){return this._hologramName}}export{s as ManipulatorMenu};class a extends o{constructor(e,t){super(e),this.buttonList=[],this._rows=t}get rows(){return this._rows}addButton(e){this.buttonList.push(e)}}export{a as NearMenu};const n=Object.freeze({Position:"position",Rotation:"rotation",Scaling:"scaling",Color:"color"});export{n as HologramProperty};const r=Object.freeze({Cube:"cube",Sphere:"sphere",Cylinder:"cylinder",Plane:"plane",Disc:"disc"});export{r as StandardShape};class l{constructor(e,t,i,o){this._name=e,this._position=t,this._rotation=i,this._scaling=o}get scaling(){return this._scaling}get rotation(){return this._rotation}get name(){return this._name}get position(){return this._position}set scaling(e){w.update&&(this._scaling=e,u.sendEvent("scalingChange",JSON.stringify({hologramName:this.name,scaling:this.scaling})))}set position(e){w.update&&(this._position=e,u.sendEvent("positionChange",JSON.stringify({hologramName:this.name,position:this.position})))}set rotation(e){w.update&&(this._rotation=e,u.sendEvent("rotationChange",JSON.stringify({hologramName:this.name,rotation:this.rotation})))}}export{l as Hologram};class h extends l{constructor(e,t,i,o,s){super(e,i,o,s),this._meshFilePath=t}get meshFilePath(){return this._meshFilePath}}export{h as ImportedHologram};class d extends l{constructor(e,t,i,o,s,a){super(e,o,s,null),this._creationOptions=i,this._shapeName=t,this._color=a}get shapeName(){return this._shapeName}get creationOptions(){return this._creationOptions}get color(){return this._color}set color(e){w.update&&(this._color=e,u.sendEvent("colorChange",JSON.stringify({hologramName:this.name,color:this.color})))}}export{d as StandardHologram};class c{constructor(e){if(!e.isSessionStarted())throw new Error("Start a session before creating the scene.");this.isSceneInitialized=!1}initializeScene(){this.#e("initialize scene"),this.isSceneInitialized=!0,u.sendEvent("initialize","")}addImportedHologram(e){return this.#e("add imported hologram"),this.#t(),this.#i(e.name),w.addHologram(e),u.sendEvent("createImportedHologram",JSON.stringify(e)),new Promise((t=>{u.listenForInfrastructureEvent("importedHologramCreated"+e.name,(()=>{t(!0)}))}))}addStandardHologram(e){return this.#e("add standard hologram"),this.#t(),this.#i(e.name),w.addHologram(e),u.sendEvent("createStandardHologram",JSON.stringify(e)),new Promise((t=>{u.listenForInfrastructureEvent("standardHologramCreated"+e.name,(()=>{t(!0)}))}))}addManipulatorMenu(e){this.#e("add manipulator menu"),this.#t(),this.#o(e.hologramName),u.sendEvent("addManipulatorMenu",JSON.stringify({name:e.hologramName,position:e.position}))}addNearMenu(e){if(this.#e("add nearMenu"),this.#t(),0===e.buttonList.length)throw new Error("Can't add a menu without button!");u.sendEvent("addNearMenu",JSON.stringify(e))}activateRenderLoop(){this.#e("activate render loop"),this.#t(),u.listenForSynchronizedElementUpdateEvents(),u.sendEvent("render","")}#t(){if(!this.isSceneInitialized)throw new Error("Scene need to be initialized before adding element or activate render loop!")}#i(e){if(p.verifyNameAlreadyExist(e))throw new Error("Element with this name "+e+" already exist!")}#o(e){if(!p.verifyNameAlreadyExist(e))throw new Error("No element exist with this name!")}#e(e){}}export{c as Scene};class g{constructor(){this._sessionStarted=!1}async startSession(e,t){if(void 0===typeof e||void 0===typeof t)throw new Error("parameters apiKey and appId can't be undefined!");this.#e("apiKey: "+e),this.#e("appId: "+t);const i=new B;return await i.sessionJoin(e,t),new Promise((e=>{this.#e("SessionManager: session started true"),this._sessionStarted=!0,e(!0)}))}addSynchronizedVariable(e){if(p.verifyNameAlreadyExist(name))throw new Error("This name was already used!");w.addSynchronizedVariable(e),u.sendEvent("createSynchronizedVariable",JSON.stringify(e))}isSessionStarted(){return this._sessionStarted}#e(e){}}export{g as SessionManager};class m{constructor(e,t){this._name=e,this._value=t}set value(e){this._value=e,u.sendEvent("valueChange",JSON.stringify({variableName:this.name,value:this.value}))}get name(){return this._name}get value(){return this._value}}export{m as SynchronizedVariable};const u=new class{constructor(){}sendEvent(t,i){e.emit(t,i)}listenForInfrastructureEvent(t,i){e.on(t,i)}listenForSynchronizedElementUpdateEvents(){e.on("updateValue",(e=>{const t=JSON.parse(e);w.updateSynchronizedVariable(t.variableName,t.value)})),e.on("updatePosition",(e=>{const t=JSON.parse(e);w.updateHologram(t.hologramName,n.Position,t.position)})),e.on("updateRotation",(e=>{const t=JSON.parse(e);w.updateHologram(t.hologramName,n.Rotation,t.rotation)})),e.on("updateScaling",(e=>{const t=JSON.parse(e);w.updateHologram(t.hologramName,n.Scaling,t.scaling)})),e.on("updateColor",(e=>{const t=JSON.parse(e);w.updateHologram(t.hologramName,n.Color,t.color)}))}};export{u as coreEventManager};const p=new class{constructor(){this.elementNames=[]}verifyNameAlreadyExist(e){return!!this.elementNames.includes(e)||(this.elementNames.push(e),!1)}};export{p as elementChecker};const w=new class{constructor(){this.holograms=new Map,this.synchronizedVariables=new Map,u.listenForInfrastructureEvent("setUpdate",(()=>this.update=!0))}get update(){return this._update}set update(e){this._update=e}addHologram(e){this.holograms.set(e.name,e)}addSynchronizedVariable(e){this.synchronizedVariables.set(e.name,e)}updateHologram(e,t,i){switch(t){case n.Position:this.#s(e,i);break;case n.Rotation:this.#a(e,i);break;case n.Scaling:this.#n(e,i);break;case n.Color:this.#r(e,i)}}updateSynchronizedVariable(e,t){this.synchronizedVariables.get(e)._value=t}#r(e,t){this.holograms.get(e)._color=t}#n(e,t){this.holograms.get(e)._scaling=t}#a(e,t){this.holograms.get(e)._rotation=t}#s(e,t){this.holograms.get(e)._position=t}};export{w as synchronizedElementUpdater};class v{constructor(e,t){this.mesh=null,this.scene=e,this.utilityLayer=t,this.isUserManipulating=!1}initializeElementManipulation(){this.boundingBox=BABYLON.BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox(this.mesh),this.sixDofDragBehavior=new BABYLON.SixDofDragBehavior,this.sixDofDragBehavior.dragDeltaRatio=1,this.sixDofDragBehavior.zDragFactor=1}renderImportedHologram(e){const t=e._meshFilePath,i=new BABYLON.Vector3(e._scaling._x,e._scaling._y,e._scaling._z),o=new BABYLON.Quaternion(e._rotation._x,e._rotation._y,e._rotation._z,e._rotation._w).toEulerAngles(),s=new BABYLON.Vector3(e._position._x,e._position._y,e._position._z),{stringSplit:a,directory:n}=this.#l(t);BABYLON.SceneLoader.LoadAssetContainer(n,a[a.length-1],this.scene,(t=>{try{t.addAllToScene(),t.meshes[0].rotationQuaternion=null,t.meshes[0].rotate(BABYLON.Axis.X,o.x),t.meshes[0].rotate(BABYLON.Axis.Y,o.y),t.meshes[0].rotate(BABYLON.Axis.Z,o.z),t.meshes[0].position=s,t.meshes[0].scaling=i,this.mesh=t.meshes[0],A.sendEvent("importedHologramCreated"+e.name,"")}catch(e){this.#e("ERROR "+e)}}))}renderStandardHologram(e){const t=e.name,i=new BABYLON.Quaternion(e._rotation._x,e._rotation._y,e._rotation._z,e._rotation._w).toEulerAngles(),o=new BABYLON.Vector3(e._position._x,e._position._y,e._position._z);this.#h(e,t),this.mesh.position=o,this.mesh.rotate(BABYLON.Axis.X,i.x),this.mesh.rotate(BABYLON.Axis.Y,i.y),this.mesh.rotate(BABYLON.Axis.Z,i.z),this.mesh.material.diffuseColor=BABYLON.Color3.FromHexString(e._color),A.sendEvent("standardHologramCreated"+e.name,"")}showOtherUserManipulation(){this.isUserManipulating=!0,this.gizmo=new BABYLON.BoundingBoxGizmo(BABYLON.Color3.FromHexString("#FF0000"),this.utilityLayer),this.gizmo.rotationSphereSize=0,this.gizmo.scaleBoxSize=0,this.gizmo.attachedMesh=this.boundingBox}addHologramManipulator(){this.isUserManipulating=!0,this.gizmo=new BABYLON.BoundingBoxGizmo(BABYLON.Color3.FromHexString("#FBFF00"),this.utilityLayer),this.gizmo.rotationSphereSize=0,this.gizmo.scaleBoxSize=.03,this.gizmo.attachedMesh=this.boundingBox,this.boundingBox.addBehavior(this.sixDofDragBehavior),console.log(this.sixDofDragBehavior)}removeHologramManipulator(){this.gizmo.attachedMesh=null,this.gizmo.dispose(),this.gizmo=null,this.boundingBox.removeBehavior(this.sixDofDragBehavior)}updatePosition(e){this.isUserManipulating?this.boundingBox.position=new BABYLON.Vector3(e._x,e._y,e._z):this.mesh.position=new BABYLON.Vector3(e._x,e._y,e._z)}updateRotation(e){const t=new BABYLON.Quaternion(e._x,e._y,e._z,e._w).toEulerAngles();this.mesh.rotate(BABYLON.Axis.X,t.x),this.mesh.rotate(BABYLON.Axis.Y,t.y),this.mesh.rotate(BABYLON.Axis.Z,t.z)}updateScaling(e){this.isUserManipulating?this.boundingBox.scaling=new BABYLON.Vector3(e._x,e._y,e._z):this.mesh.scaling=new BABYLON.Vector3(e._x,e._y,e._z)}updateColor(e){this.mesh.material.diffuseColor=BABYLON.Color3.FromHexString(e)}#h(e,t){switch(e._shapeName){case r.Cube:this.mesh=BABYLON.MeshBuilder.CreateBox(t,e._creationOptions,this.scene);break;case r.Sphere:this.mesh=BABYLON.MeshBuilder.CreateSphere(t,e._creationOptions,this.scene);break;case r.Cylinder:this.mesh=BABYLON.MeshBuilder.CreateCylinder(t,e._creationOptions,this.scene);break;case r.Plane:this.mesh=BABYLON.MeshBuilder.CreatePlane(t,e._creationOptions,this.scene);break;case r.Disc:this.mesh=BABYLON.MeshBuilder.CreateDisc(t,e._creationOptions,this.scene);break;default:throw new Error("The required shape is not supported")}const i=new BABYLON.StandardMaterial("material",this.scene);i.diffuseColor=BABYLON.Color3.FromHexString(e._color),this.mesh.material=i}#l(e){const t=e.split("/");let i="";for(let e=0;e<t.length-1;e++)i+=t[e]+"/";return{stringSplit:t,directory:i}}#e(e){}}export{v as HologramRenderer};class b{constructor(){this.hologramRenders=new Map}initializeScene(){const e=document.getElementById("renderCanvas");this.#e("initialize scene called"),this.engine=new BABYLON.Engine(e,!0),this.scene=new BABYLON.Scene(this.engine),this.scene.clearColor=new BABYLON.Color3.Black;const t=new BABYLON.FreeCamera("camera1",new BABYLON.Vector3(0,1.3,-.3),this.scene);t.minZ=.01,t.attachControl(e,!0),t.inputs.addMouseWheel();new BABYLON.HemisphericLight("light",new BABYLON.Vector3(1,1,0)).intensity=1,this.utilityLayer=new BABYLON.UtilityLayerRenderer(this.scene),this.utilityLayer.utilityLayerScene.autoClearDepthAndStencil=!1,this.GUIManager=new BABYLON.GUI.GUI3DManager(this.scene),this.GUIManager.useRealisticScaling=!0}activateRenderLoop(){this.#e("activate render loop called"),this.#d().then((e=>{this.engine.runRenderLoop((()=>e.render()))}))}addStandardHologram(e){this.#e("addStandardHologram");const t=new v(this.scene,this.utilityLayer);t.renderStandardHologram(e),this.hologramRenders.set(e.name,t)}addImportedHologram(e){this.#e("addImportedHologram");const t=new v(this.scene,this.utilityLayer);t.renderImportedHologram(e),this.hologramRenders.set(e.name,t)}addNearMenu(e,t,i){const o=new BABYLON.GUI.NearMenu("NearMenu");let s=[];return o.rows=t,this.GUIManager.addControl(o),o.isPinned=!0,o.position=new BABYLON.Vector3(e._x,e._y,e._z),i.forEach((e=>{const t=new BABYLON.GUI.TouchHolographicButton;t.name=e._name,t.text=e._text,s.push(t),o.addButton(t)})),s}async#d(){let e;await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar")?(this.#e("IMMERSIVE AR SUPPORTED"),e=await this.scene.createDefaultXRExperienceAsync({uiOptions:{sessionMode:"immersive-ar",referenceSpaceType:"local-floor"}})):(this.#e("IMMERSIVE VR SUPPORTED"),e=await this.scene.createDefaultXRExperienceAsync({uiOptions:{sessionMode:"immersive-vr"}}));try{e.baseExperience.featuresManager.enableFeature(BABYLON.WebXRFeatureName.HAND_TRACKING,"latest",{xrInput:xr.input})}catch(e){this.#e("Articulated hand tracking not supported in this device.")}return this.scene}#e(e){}}export{b as SceneManager};class B{constructor(){this.debug=!0}sessionJoin(e,t){return this.debug&&console.log("Croquet session: session join"),Croquet.Session.join({apiKey:e,appId:t,name:Croquet.App.autoSession(),password:Croquet.App.autoPassword(),model:N,view:S,autoSleep:!1})}}export{B as CroquetSession};class N extends Croquet.Model{init(){this.linkedViews=[],this.animationModels=new Map,this.hologramModel=y.create(),this.synchronizedVariableModel=M.create(),this.subscribe(this.sessionId,"view-join",this.viewJoin),this.subscribe(this.sessionId,"view-exit",this.viewDrop),this.#c()}viewJoin(e){this.#e("received view join"),this.linkedViews.push(e)}viewDrop(e){this.#e("received view left"),this.linkedViews.splice(this.linkedViews.indexOf(e),1),e===this.viewInCharge&&(this.viewInCharge=this.linkedViews[0],this.publish(this.viewInCharge,"setUpdate"))}createNewAnimation(e){this.#e("received create new Animation");const t=e._name,i=e._time;this.animationModels.has(t)||this.animationModels.set(t,_.create({name:t,time:i}))}destroyAnimation(e){this.#e("received stop animation"),this.animationModels.has(e)&&(this.animationModels.get(e).destroy(),this.animationModels.delete(e))}setViewInCharge(e){this.viewInCharge=e}#c(){this.subscribe("animation","createAnimation",this.createNewAnimation),this.subscribe("animation","stopAnimation",this.destroyAnimation),this.subscribe("view","viewInCharge",this.setViewInCharge)}#e(e){}static types(){return{Map:Map}}}N.register("RootModel");export{N as RootModel};class _ extends Croquet.Model{init(e={}){super.init(),this.name=e.name,this.time=e.time,this.future(this.time).tick()}tick(){this.#e("model emit"+this.name),this.publish("view","animationTick",this.name),this.future(this.time).tick()}#e(e){}}_.register("AnimationModel");export{_ as AnimationModel};class y extends Croquet.Model{init(e={}){super.init(),this.holograms=new Map,this.linkedViews=[],this.hologramInUserControl=new Map,this.subscribe(this.sessionId,"view-join",this.viewJoin),this.subscribe(this.sessionId,"view-exit",this.viewDrop),this.#c()}viewJoin(e){this.#e("received view join"),this.linkedViews.push(e)}viewDrop(e){this.#e("received view left");const t=[...this.hologramInUserControl.values()];this.linkedViews.splice(this.linkedViews.indexOf(e),1),t.includes(e)&&this.hologramInUserControl.forEach(((t,i)=>{t===e&&this.manageUserHologramControlReleased({view:t,hologramName:i})}))}addImportedHologram(e){const t=Object.create(x.prototype,Object.getOwnPropertyDescriptors(e.hologram)),i=e.view;this.#g(t,i),this.publish(i,"showImportedHologram",t.name)}addStandardHologram(e){const t=Object.create(O.prototype,Object.getOwnPropertyDescriptors(e.hologram)),i=e.view;this.#g(t,i),this.publish(i,"showStandardHologram",t.name)}updatePosition(e){const t=e.hologramName,i=e.position;this.holograms.get(t).position=i,A.sendEvent("updatePosition",JSON.stringify({hologramName:t,position:i})),this.publish("view","updateHologramPosition",t)}updateScaling(e){const t=e.hologramName,i=e.scaling;this.holograms.get(t).scaling=i,A.sendEvent("updateScaling",JSON.stringify({hologramName:t,scale:i})),this.publish("view","updateHologramScaling",t)}updateRotation(e){const t=e.hologramName,i=e.rotation;this.holograms.get(t).rotation=i,A.sendEvent("updateRotation",JSON.stringify({hologramName:t,rotation:i})),this.publish("view","updateHologramRotation",t)}updateColor(e){const t=e.hologramName,i=e.color;this.holograms.get(t).color=i,A.sendEvent("updateColor",JSON.stringify({hologramName:t,color:i})),this.publish("view","updateHologramColor",t)}requireShowUserManipulation(e){this.#e("received showUserManipulation"),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"showUserManipulation",{hologramName:e.hologramName})}))}manageUserHologramControlRequired(e){this.#e("received manage user hologram control"),this.hologramInUserControl.set(e.hologramName,e.view),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"freezeControlButton",{hologramName:e.hologramName})}))}manageUserHologramControlReleased(e){this.#e("received manage user hologram control released"),this.hologramInUserControl.delete(e.hologramName),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"restoreControlButton",{hologramName:e.hologramName})}))}updateHologramPositionAfterManipulation(e){this.#e("received requireHologramUpdate");const t=e.hologramName,i=new I(e.position_x,e.position_y,e.position_z);this.holograms.get(t).position=i,A.sendEvent("updatePosition",JSON.stringify({hologramName:t,position:i})),this.linkedViews.filter((t=>e.view!==t)).forEach((e=>{this.publish(e,"showHologramUpdatedPosition",t)}))}updateHologramScalingAfterManipulation(e){this.#e("received requireHologramUpdate");const t=e.hologramName,i=new I(e.scale_x,e.scale_y,e.scale_z);this.holograms.get(t).scaling=i,A.sendEvent("updateScaling",JSON.stringify({hologramName:t,scale:i})),this.linkedViews.filter((t=>e.view!==t)).forEach((e=>{this.publish(e,"showHologramUpdatedScaling",t)}))}#g(e){this.holograms.has(e.name)||this.holograms.set(e.name,e)}#c(){this.subscribe("create","importedHologram",this.addImportedHologram),this.subscribe("create","standardHologram",this.addStandardHologram),this.subscribe("updateHologram","changeColor",this.updateColor),this.subscribe("updateHologram","changeScaling",this.updateScaling),this.subscribe("updateHologram","changePosition",this.updatePosition),this.subscribe("updateHologram","changeRotation",this.updateRotation),this.subscribe("hologramManipulator","showUserManipulation",this.requireShowUserManipulation),this.subscribe("hologramManipulation","positionChanged",this.updateHologramPositionAfterManipulation),this.subscribe("hologramManipulation","scaleChanged",this.updateHologramScalingAfterManipulation),this.subscribe("controlButton","released",this.manageUserHologramControlReleased),this.subscribe("controlButton","clicked",this.manageUserHologramControlRequired)}#e(e){}static types(){return{CroquetStandardHologram:O,CroquetImportedHologram:x,Vector3:I,Quaternion:H}}}y.register("HologramModel");export{y as HologramModel};class M extends Croquet.Model{init(e={}){super.init(),this.syncrhonizedVariables=new Map,this.#c()}addVariable(e){const t=Object.create(E.prototype,Object.getOwnPropertyDescriptors(e));if(this.syncrhonizedVariables.has(t.name)){const e=this.syncrhonizedVariables.get(t.name).value;A.sendEvent("updateValue",JSON.stringify({variableName:t.name,value:e}))}else this.syncrhonizedVariables.set(t.name,t)}updateValue(e){const t=e.variableName,i=e.value;this.syncrhonizedVariables.get(t).value!==i&&(this.syncrhonizedVariables.get(t).value=i,A.sendEvent("updateValue",JSON.stringify({variableName:t,value:i})))}#c(){this.subscribe("create","synchronizedVariable",this.addVariable),this.subscribe("synchronizedVariable","valueChange",this.updateValue)}static types(){return{CroquetSynchronizedVariable:E}}}M.register("SynchronizedVariableModel");export{M as SynchronizedVariableModel};class f extends Croquet.View{constructor(e,t){super(e),this.model=e,this.sceneManager=t,this.hologramsManipulatorMenu=new Map,this.#m()}addManipulatorMenu(e,t){const i=new BABYLON.GUI.NearMenu("NearMenu");i.rows=1,this.sceneManager.GUIManager.addControl(i),i.isPinned=!0,this.sceneManager.hologramRenders.get(e).initializeElementManipulation(),i.parent=this.sceneManager.hologramRenders.get(e).mesh,i.position=new BABYLON.Vector3(t._x,t._y,t._z);const o=new BABYLON.GUI.HolographicButton("manipulate",!1);i.addButton(o),this.#u(e,o),this.hologramsManipulatorMenu.set(e,new z(i,o))}showImportedHologram(e){this.sceneManager.addImportedHologram(this.model.holograms.get(e))}showStandardHologram(e){this.sceneManager.addStandardHologram(this.model.holograms.get(e))}showUserManipulation(e){this.#e("received show userManipulation "+e.hologramName);const t=e.hologramName;this.sceneManager.hologramRenders.get(t).showOtherUserManipulation()}showHologramUpdatedPosition(e){const t=this.model.holograms.get(e).position;this.sceneManager.hologramRenders.get(e).updatePosition(t)}showHologramUpdatedRotation(e){const t=this.model.holograms.get(e).rotation;this.sceneManager.hologramRenders.get(e).updateRotation(t)}showHologramUpdatedScaling(e){const t=this.model.holograms.get(e).scaling;this.sceneManager.hologramRenders.get(e).updateScaling(t)}showHologramUpdatedColor(e){this.#e("received updateHologramColor"),this.sceneManager.hologramRenders.get(e).updateColor(this.model.holograms.get(e).color)}freezeControlButton(e){this.#e("received freezeControlButton hologram "+e.hologramName);const t=e.hologramName,i=this.hologramsManipulatorMenu.get(t);this.#p(i.y)}restoreControlButton(e){this.#e("received restore ControlButton hologram "+e.hologramName);const t=e.hologramName,i=this.hologramsManipulatorMenu.get(t);this.sceneManager.hologramRenders.get(t).removeHologramManipulator(),this.#u(e.hologramName,i.y)}clockEventTick(){this.timeElapsed=!0}#p(e){e.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,e.frontMaterial.albedoColor=BABYLON.Color3.Red(),e.backMaterial.albedoColor=new BABYLON.Color3(.67,.29,.29),e.imageUrl="https://raw.githubusercontent.com/AnnaVitali/framework-collaborativeXR/master/img/IconClose.png",e.onPointerDownObservable.clear()}#w(e){this.#e("user start manipulating hologram "+e),this.publish("controlButton","clicked",{view:this.viewId,hologramName:e})}#v(e){this.#e("user stop manipulating"),this.publish("controlButton","released",{view:this.viewId,hologramName:e})}#u(e,t){t.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,t.frontMaterial.albedoColor=BABYLON.Color3.Blue(),t.backMaterial.albedoColor=new BABYLON.Color3(.29,.37,.67),t.text="Manipulate",t.imageUrl="https://raw.githubusercontent.com/AnnaVitali/framework-collaborativeXR/master/img/IconAdjust.png",t.onPointerDownObservable.clear(),t.onPointerDownObservable.add((()=>{this.#e("clicked"),this.#w(e);const i=this.sceneManager.hologramRenders.get(e);i.addHologramManipulator();let o=0;this.timeElapsed=!1;let s=!1;i.sixDofDragBehavior.onPositionChangedObservable.add((()=>{o+=1,s||(this.future(1e3).clockEventTick(),s=!0),o<20&&!this.timeElapsed?this.publish("hologramManipulation","positionChanged",this.#b(e,i)):this.timeElapsed&&(s=!1,this.timeElapsed=!1,o=0)})),i.gizmo.onScaleBoxDragObservable.add((()=>{this.publish("hologramManipulation","scaleChanged",this.#B(e,i))})),this.#N(e,t),this.publish("hologramManipulator","showUserManipulation",{view:this.viewId,hologramName:e})}))}#b(e,t){const i=t.boundingBox.absolutePosition;return{hologramName:e,view:this.viewId,position_x:i.x,position_y:i.y,position_z:i.z}}#B(e,t){const i=t.boundingBox.absoluteScaling;return{hologramName:e,view:this.viewId,scale_x:i.x,scale_y:i.y,scale_z:i.z}}#N(e,t){t.text="Stop manipulating",t.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,t.frontMaterial.albedoColor=BABYLON.Color3.Green(),t.backMaterial.albedoColor=new BABYLON.Color3(.29,.67,.45),t.onPointerDownObservable.clear(),t.onPointerDownObservable.add((()=>{this.#v(e),this.sceneManager.hologramRenders.get(e).removeHologramManipulator(),this.#u(e,t)}))}showCurrentManipulation(){this.model.hologramInUserControl.forEach(((e,t)=>{this.sceneManager.hologramRenders.get(t).showOtherUserManipulation(),this.freezeControlButton({hologramName:t})}))}#m(){this.subscribe(this.viewId,"freezeControlButton",this.freezeControlButton),this.subscribe(this.viewId,"restoreControlButton",this.restoreControlButton),this.subscribe(this.viewId,"showUserManipulation",this.showUserManipulation),this.subscribe(this.viewId,"showHologramUpdatedPosition",this.showHologramUpdatedPosition),this.subscribe(this.viewId,"showHologramUpdatedScaling",this.showHologramUpdatedScaling),this.subscribe(this.viewId,"showImportedHologram",this.showImportedHologram),this.subscribe(this.viewId,"showStandardHologram",this.showStandardHologram),this.subscribe("view","updateHologramColor",this.showHologramUpdatedColor),this.subscribe("view","updateHologramScaling",this.showHologramUpdatedScaling),this.subscribe("view","updateHologramPosition",this.showHologramUpdatedPosition),this.subscribe("view","updateHologramRotation",this.showHologramUpdatedRotation)}#e(e){}}export{f as HologramView};class S extends Croquet.View{constructor(e){super(e),this.model=e,this.sceneManager=new b,this.hologramView=new f(this.model.hologramModel,this.sceneManager),A.setRootView(this),this.#_(),this.#m(),A.listenForCoreEvents()}initializeScene(){const e=document.createElement("canvas");e.setAttribute("id","renderCanvas"),e.setAttribute("style","width: 100%; height: 100%"),document.body.appendChild(e),this.sceneManager.initializeScene()}runRenderLoop(){this.hologramView.showCurrentManipulation(),this.sceneManager.activateRenderLoop()}notifyEventToModel(e,t,i){this.publish(e,t,i)}addNearMenu(t,i,o){this.sceneManager.addNearMenu(i,t,o).forEach((t=>{t.onPointerDownObservable.add((()=>{e.emit(t.name,"")}))}))}propagateTick(e){A.sendEvent(e,"")}setElementUpdate(){this.#e("received setUpdate"),A.sendEvent("setUpdate","")}#_(){1===this.model.linkedViews.length&&(this.#e("set view in charge"),this.publish("view","viewInCharge",this.viewId),this.setElementUpdate())}#m(){this.subscribe(this.viewId,"setUpdate",this.setElementUpdate),this.subscribe("view","animationTick",this.propagateTick)}#e(e){}}export{S as RootView};class C{constructor(e,t,i,o){this._name=e,this._position=t,this._rotation=i,this._scaling=o}get name(){return this._name}get position(){return this._position}get rotation(){return this._rotation}get scaling(){return this._scaling}set name(e){this._name=e}set position(e){this._position=e}set rotation(e){this._rotation=e}set scaling(e){this._scaling=e}}export{C as HologramClone};class x extends C{constructor(e,t,i,o,s){super(e,i,o,s),this._meshFilePath=t}get meshFilePath(){return this._meshFilePath}}export{x as ImportedHologramClone};class O extends C{constructor(e,t,i,o,s,a){super(e,o,s,null),this._creationOptions=i,this._shapeName=t,this._color=a}get shapeName(){return this._shapeName}get creationOptions(){return this._creationOptions}get color(){return this._color}set color(e){this._color=e}}export{O as StandardHologramClone};class E{constructor(e,t){this._name=e,this._value=t}get name(){return this._name}get value(){return this._value}set value(e){this._value=e}}export{E as SynchronizedVariableClone};const A=new class{constructor(){this.view=null}sendEvent(t,i){e.emit(t,i)}setRootView(e){this.view=e}listenForCoreEvents(){e.on("initialize",(()=>{this.#e("initialize scene"),this.view.initializeScene()})),e.on("render",(()=>{this.#e("run render loop"),this.view.runRenderLoop()})),e.on("createImportedHologram",(e=>{this.#e("create imported hologram"),this.view.notifyEventToModel("create","importedHologram",{view:this.view.viewId,hologram:JSON.parse(e)})})),e.on("createStandardHologram",(e=>{this.#e("create standard hologram"),this.view.notifyEventToModel("create","standardHologram",{view:this.view.viewId,hologram:JSON.parse(e)})})),e.on("createSynchronizedVariable",(e=>{this.#e("create synchronized variable"),this.view.notifyEventToModel("create","synchronizedVariable",JSON.parse(e))})),e.on("addManipulatorMenu",(e=>{this.#e("add manipulator menu");const t=JSON.parse(e),i=t.name,o=t.position;this.view.hologramView.addManipulatorMenu(i,o)})),e.on("addNearMenu",(e=>{this.#e("add near menu");const t=JSON.parse(e),i=t._rows,o=t._position,s=t.buttonList;this.view.addNearMenu(i,o,s)})),e.on("newAnimation",(e=>{this.#e("add animation"),this.view.notifyEventToModel("animation","createAnimation",JSON.parse(e))})),e.on("stopAnimation",(e=>{this.#e("stop animation"),this.view.notifyEventToModel("animation","stopAnimation",JSON.parse(e))})),e.on("valueChange",(e=>{this.view.notifyEventToModel("synchronizedVariable","valueChange",JSON.parse(e))})),e.on("colorChange",(e=>{this.view.notifyEventToModel("updateHologram","changeColor",JSON.parse(e))})),e.on("scalingChange",(e=>{this.view.notifyEventToModel("updateHologram","changeScaling",JSON.parse(e))})),e.on("positionChange",(e=>{this.view.notifyEventToModel("updateHologram","changePosition",JSON.parse(e))})),e.on("rotationChange",(e=>{this.view.notifyEventToModel("updateHologram","changeColor",JSON.parse(e))}))}#e(e){}};export{A as infrastructureEventManager};class H{constructor(e,t,i,o){this._x=e,this._y=t,this._z=i,this._w=o}get x(){return this._x}get y(){return this._y}get z(){return this._z}get w(){return this._w}}export{H as Quaternion};class z{constructor(e,t,i){this._x=e,this._y=t,this._z=i}get x(){return this._x}get y(){return this._y}get z(){return this._z}}export{z as Triple};class I{constructor(e,t,i){this._x=e,this._y=t,this._z=i}get x(){return this._x}get y(){return this._y}get z(){return this._z}}export{I as Vector3};