class EventBus{constructor(){this.listeners=[]}emit(e,t){this.listeners.filter((({name:t})=>t===e)).forEach((({callback:e})=>{setTimeout(e.apply(this,[t]),0)}))}on(e,t){"function"==typeof t&&"string"==typeof e&&this.listeners.push({name:e,callback:t})}off(e,t){this.listeners=this.listeners.filter((o=>!(o.name===e&&o.callback===t)))}destroy(){this.listeners.length=0}}const eventBus=new EventBus;export{eventBus};class Animation{constructor(e,t){if(elementChecker.verifyNameAlreadyExist(e))throw new Error("This name was already used!");this._name=e,this._time=t}get name(){return this._name}get time(){return this._time}setAnimationCallback(e){this.animationCallback=()=>{setTimeout(e.apply(this),0)},coreEventManager.listenForInfrastructureEvent(this.name,this.animationCallback)}startAnimation(){synchronizedElementUpdater.update&&coreEventManager.sendEvent("newAnimation",JSON.stringify(this))}stopAnimation(){synchronizedElementUpdater.update&&coreEventManager.sendEvent("stopAnimation",JSON.stringify(this.name))}}export{Animation};class Menu{constructor(e){this._position=e}get position(){return this._position}}export{Menu};class Button{constructor(e,t){this._text=t,this._name=e}get name(){return this._name}get text(){return this._text}set text(e){this._text=e}setOnPointerDownCallback(e){coreEventManager.listenForInfrastructureEvent(this.name,(()=>{synchronizedElementUpdater.update?setTimeout(e.apply(this),0):(synchronizedElementUpdater.update=!0,setTimeout(e.apply(this),0),synchronizedElementUpdater.update=!1)}))}}export{Button};class ManipulatorMenu extends Menu{constructor(e,t){super(e),this._position=e,this._hologramName=t}get hologramName(){return this._hologramName}}export{ManipulatorMenu};class NearMenu extends Menu{constructor(e,t){super(e),this.buttonList=[],this._rows=t}get rows(){return this._rows}addButton(e){this.buttonList.push(e)}}export{NearMenu};const HologramProperty=Object.freeze({Position:"position",Rotation:"rotation",Scaling:"scaling",Color:"color"});export{HologramProperty};const StandardShape=Object.freeze({Cube:"cube",Sphere:"sphere",Cylinder:"cylinder",Plane:"plane",Disc:"disc"});export{StandardShape};class Hologram{constructor(e,t,o,i){this._name=e,this._position=t,this._rotation=o,this._scaling=i}get scaling(){return this._scaling}get rotation(){return this._rotation}get name(){return this._name}get position(){return this._position}set scaling(e){synchronizedElementUpdater.update&&(this._scaling=e,coreEventManager.sendEvent("scalingChange",JSON.stringify({hologramName:this.name,scaling:this.scaling})))}set position(e){synchronizedElementUpdater.update&&(this._position=e,coreEventManager.sendEvent("positionChange",JSON.stringify({hologramName:this.name,position:this.position})))}set rotation(e){synchronizedElementUpdater.update&&(this._rotation=e,coreEventManager.sendEvent("rotationChange",JSON.stringify({hologramName:this.name,rotation:this.rotation})))}changeScalingWithoutSync(e){this._scaling=e}changePositionWithoutSync(e){this._position=e}changeRotationWithoutSync(e){this._rotation=e}}export{Hologram};class ImportedHologram extends Hologram{constructor(e,t,o,i,a){super(e,o,i,a),this._meshFilePath=t}get meshFilePath(){return this._meshFilePath}}export{ImportedHologram};class StandardHologram extends Hologram{constructor(e,t,o,i,a,n){super(e,i,a,null),this._creationOptions=o,this._shapeName=t,this._color=n}get shapeName(){return this._shapeName}get creationOptions(){return this._creationOptions}get color(){return this._color}set color(e){synchronizedElementUpdater.update&&(this._color=e,coreEventManager.sendEvent("colorChange",JSON.stringify({hologramName:this.name,color:this.color})))}changeColorWithoutSync(e){this._color=e}}export{StandardHologram};class Scene{constructor(e){if(!e.isSessionStarted())throw new Error("Start a session before creating the scene.");this.isSceneInitialized=!1}initializeScene(){this.#e("initialize scene"),this.isSceneInitialized=!0,coreEventManager.sendEvent("initialize","")}addImportedHologram(e){return this.#e("add imported hologram"),this.#t(),this.#o(e.name),synchronizedElementUpdater.addHologram(e),coreEventManager.sendEvent("createImportedHologram",JSON.stringify(e)),new Promise((t=>{coreEventManager.listenForInfrastructureEvent("importedHologramCreated"+e.name,(()=>{t(!0)}))}))}addStandardHologram(e){return this.#e("add standard hologram"),this.#t(),this.#o(e.name),synchronizedElementUpdater.addHologram(e),coreEventManager.sendEvent("createStandardHologram",JSON.stringify(e)),new Promise((t=>{coreEventManager.listenForInfrastructureEvent("standardHologramCreated"+e.name,(()=>{t(!0)}))}))}addManipulatorMenu(e){this.#e("add manipulator menu"),this.#t(),this.#i(e.hologramName),coreEventManager.sendEvent("addManipulatorMenu",JSON.stringify({name:e.hologramName,position:e.position}))}addNearMenu(e){if(this.#e("add nearMenu"),this.#t(),0===e.buttonList.length)throw new Error("Can't add a menu without button!");coreEventManager.sendEvent("addNearMenu",JSON.stringify(e))}activateRenderLoop(){this.#e("activate render loop"),this.#t(),coreEventManager.listenForSynchronizedElementUpdateEvents(),coreEventManager.sendEvent("render","")}#t(){if(!this.isSceneInitialized)throw new Error("Scene need to be initialized before adding element or activate render loop!")}#o(e){if(elementChecker.verifyNameAlreadyExist(e))throw new Error("Element with this name "+e+" already exist!")}#i(e){if(!elementChecker.verifyNameAlreadyExist(e))throw new Error("No element exist with this name!")}#e(e){}}export{Scene};class SessionManager{constructor(){this._sessionStarted=!1}async startSession(e,t){if(void 0===typeof e||void 0===typeof t)throw new Error("parameters apiKey and appId can't be undefined!");this.#e("apiKey: "+e),this.#e("appId: "+t);const o=new CroquetSession;return await o.sessionJoin(e,t),new Promise((e=>{this.#e("SessionManager: session started true"),this._sessionStarted=!0,e(!0)}))}addStandardObject(e){if(elementChecker.verifyNameAlreadyExist(name))throw new Error("This name was already used!");synchronizedElementUpdater.addStandardObject(e),coreEventManager.sendEvent("createStandardObject",JSON.stringify(e))}isSessionStarted(){return this._sessionStarted}#e(e){}}export{SessionManager};class StandardObject{constructor(e,t){this._name=e,this._value=t}set value(e){this._value=e,coreEventManager.sendEvent("valueChange",JSON.stringify({variableName:this.name,value:this.value}))}changeValueWithoutSync(e){this._value=e}get name(){return this._name}get value(){return this._value}}export{StandardObject};class CoreEventManager{constructor(){}sendEvent(e,t){eventBus.emit(e,t)}listenForInfrastructureEvent(e,t){eventBus.on(e,t)}listenForSynchronizedElementUpdateEvents(){eventBus.on("updateValue",(e=>{const t=JSON.parse(e);synchronizedElementUpdater.updateStandardObject(t.variableName,t.value)})),eventBus.on("updatePosition",(e=>{const t=JSON.parse(e);synchronizedElementUpdater.updateHologram(t.hologramName,HologramProperty.Position,t.position)})),eventBus.on("updateRotation",(e=>{const t=JSON.parse(e);synchronizedElementUpdater.updateHologram(t.hologramName,HologramProperty.Rotation,t.rotation)})),eventBus.on("updateScaling",(e=>{const t=JSON.parse(e);synchronizedElementUpdater.updateHologram(t.hologramName,HologramProperty.Scaling,t.scaling)})),eventBus.on("updateColor",(e=>{const t=JSON.parse(e);synchronizedElementUpdater.updateHologram(t.hologramName,HologramProperty.Color,t.color)}))}}const coreEventManager=new CoreEventManager;export{coreEventManager};class ElementChecker{constructor(){this.elementNames=[]}verifyNameAlreadyExist(e){return!!this.elementNames.includes(e)||(this.elementNames.push(e),!1)}}const elementChecker=new ElementChecker;export{elementChecker};class SynchronizedElementUpdater{constructor(){this.holograms=new Map,this.standardObjects=new Map,coreEventManager.listenForInfrastructureEvent("setUpdate",(()=>this.update=!0))}get update(){return this._update}set update(e){this._update=e}addHologram(e){this.holograms.set(e.name,e)}addStandardObject(e){this.standardObjects.set(e.name,e)}updateHologram(e,t,o){switch(t){case HologramProperty.Position:this.#a(e,o);break;case HologramProperty.Rotation:this.#n(e,o);break;case HologramProperty.Scaling:this.#r(e,o);break;case HologramProperty.Color:this.#s(e,o)}}updateStandardObject(e,t){this.standardObjects.get(e).changeValueWithoutSync(t)}#s(e,t){this.holograms.get(e).changeColorWithoutSync(t)}#r(e,t){this.holograms.get(e).changeScalingWithoutSync(t)}#n(e,t){this.holograms.get(e).changeRotationWithoutSync(t)}#a(e,t){this.holograms.get(e).changePositionWithoutSync(t)}}const synchronizedElementUpdater=new SynchronizedElementUpdater;export{synchronizedElementUpdater};class CroquetSession{constructor(){this.debug=!0}sessionJoin(e,t){return this.debug&&console.log("Croquet session: session join"),Croquet.Session.join({apiKey:e,appId:t,name:Croquet.App.autoSession(),password:Croquet.App.autoPassword(),model:RootModel,view:RootView,autoSleep:!1})}}export{CroquetSession};class RootModel extends Croquet.Model{init(){this.linkedViews=[],this.animationModels=new Map,this.hologramModel=HologramModel.create(),this.standardObjectModel=StandardObjectModel.create(),this.subscribe(this.sessionId,"view-join",this.viewJoin),this.subscribe(this.sessionId,"view-exit",this.viewDrop),this.#l()}viewJoin(e){this.#e("received view join"),this.linkedViews.push(e)}viewDrop(e){this.#e("received view left"),this.linkedViews.splice(this.linkedViews.indexOf(e),1),e===this.viewInCharge&&(this.viewInCharge=this.linkedViews[0],this.publish(this.viewInCharge,"setUpdate"))}createNewAnimation(e){this.#e("received create new Animation");const t=e._name,o=e._time;this.animationModels.has(t)||this.animationModels.set(t,AnimationModel.create({name:t,time:o}))}destroyAnimation(e){this.#e("received stop animation"),this.animationModels.has(e)&&(this.animationModels.get(e).destroy(),this.animationModels.delete(e))}setViewInCharge(e){this.viewInCharge=e}#l(){this.subscribe("animation","createAnimation",this.createNewAnimation),this.subscribe("animation","stopAnimation",this.destroyAnimation),this.subscribe("view","viewInCharge",this.setViewInCharge)}#e(e){}static types(){return{Map:Map}}}RootModel.register("RootModel");export{RootModel};class AnimationModel extends Croquet.Model{init(e={}){super.init(),this.name=e.name,this.time=e.time,this.future(this.time).tick()}tick(){this.#e("model emit"+this.name),this.publish("view","animationTick",this.name),this.future(this.time).tick()}#e(e){}}AnimationModel.register("AnimationModel");export{AnimationModel};class HologramModel extends Croquet.Model{init(e={}){super.init(),this.holograms=new Map,this.linkedViews=[],this.hologramInUserControl=new Map,this.subscribe(this.sessionId,"view-join",this.viewJoin),this.subscribe(this.sessionId,"view-exit",this.viewDrop),this.#l()}viewJoin(e){this.#e("received view join"),this.linkedViews.push(e)}viewDrop(e){this.#e("received view left");const t=[...this.hologramInUserControl.values()];this.linkedViews.splice(this.linkedViews.indexOf(e),1),t.includes(e)&&this.hologramInUserControl.forEach(((t,o)=>{t===e&&this.manageUserHologramControlReleased({view:t,hologramName:o})}))}addImportedHologram(e){const t=Object.create(ImportedHologram.prototype,Object.getOwnPropertyDescriptors(e.hologram)),o=e.view;this.#h(t,o),this.publish(o,"showImportedHologram",t.name)}addStandardHologram(e){const t=Object.create(StandardHologram.prototype,Object.getOwnPropertyDescriptors(e.hologram)),o=e.view;this.#h(t,o),this.publish(o,"showStandardHologram",t.name)}updatePosition(e){const t=e.hologramName,o=e.position;this.holograms.get(t).changePositionWithoutSync(o),infrastructureEventManager.sendEvent("updatePosition",JSON.stringify({hologramName:t,position:o})),this.publish("view","updateHologramPosition",t)}updateScaling(e){const t=e.hologramName,o=e.scaling;this.holograms.get(t).changeScalingWithoutSync(o),infrastructureEventManager.sendEvent("updateScaling",JSON.stringify({hologramName:t,scale:o})),this.publish("view","updateHologramScaling",t)}updateRotation(e){const t=e.hologramName,o=e.rotation;this.holograms.get(t).changeRotationWithoutSync(o),infrastructureEventManager.sendEvent("updateRotation",JSON.stringify({hologramName:t,rotation:o})),this.publish("view","updateHologramRotation",t)}updateColor(e){const t=e.hologramName,o=e.color;this.holograms.get(t).changeColorWithoutSync(o),infrastructureEventManager.sendEvent("updateColor",JSON.stringify({hologramName:t,color:o})),this.publish("view","updateHologramColor",t)}requireShowUserManipulation(e){this.#e("received showUserManipulation"),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"showUserManipulation",{hologramName:e.hologramName})}))}manageUserHologramControlRequired(e){this.#e("received manage user hologram control"),this.hologramInUserControl.set(e.hologramName,e.view),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"freezeControlButton",{hologramName:e.hologramName})}))}manageUserHologramControlReleased(e){this.#e("received manage user hologram control released"),this.hologramInUserControl.delete(e.hologramName),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"restoreControlButton",{hologramName:e.hologramName})}))}updateHologramPositionAfterManipulation(e){this.#e("received requireHologramUpdate");const t=e.hologramName,o=new Vector3(e.hologram_position_x,e.hologram_position_y,e.hologram_position_z);this.holograms.get(t).changePositionWithoutSync(o),infrastructureEventManager.sendEvent("updatePosition",JSON.stringify({hologramName:t,position:o})),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"showHologramUpdatedPosition",e)}))}updateHologramScalingAfterManipulation(e){this.#e("received requireHologramUpdate");const t=e.hologramName,o=new Vector3(e.hologram_scale_x,e.hologram_scale_y,e.hologram_scale_z);this.holograms.get(t).changeScalingWithoutSync(o),infrastructureEventManager.sendEvent("updateScaling",JSON.stringify({hologramName:t,scale:o})),this.linkedViews.filter((t=>e.view!==t)).forEach((t=>{this.publish(t,"showHologramUpdatedScaling",e)}))}#h(e){this.holograms.has(e.name)||this.holograms.set(e.name,e)}#l(){this.subscribe("create","importedHologram",this.addImportedHologram),this.subscribe("create","standardHologram",this.addStandardHologram),this.subscribe("updateHologram","changeColor",this.updateColor),this.subscribe("updateHologram","changeScaling",this.updateScaling),this.subscribe("updateHologram","changePosition",this.updatePosition),this.subscribe("updateHologram","changeRotation",this.updateRotation),this.subscribe("hologramManipulator","showUserManipulation",this.requireShowUserManipulation),this.subscribe("hologramManipulation","positionChanged",this.updateHologramPositionAfterManipulation),this.subscribe("hologramManipulation","scaleChanged",this.updateHologramScalingAfterManipulation),this.subscribe("controlButton","released",this.manageUserHologramControlReleased),this.subscribe("controlButton","clicked",this.manageUserHologramControlRequired)}#e(e){}static types(){return{StandardHologram:StandardHologram,ImportedHologram:ImportedHologram,Vector3:Vector3,Quaternion:Quaternion}}}HologramModel.register("HologramModel");export{HologramModel};class StandardObjectModel extends Croquet.Model{init(e={}){super.init(),this.syncrhonizedVariables=new Map,this.#l()}addStandardObject(e){const t=Object.create(StandardObject.prototype,Object.getOwnPropertyDescriptors(e));if(this.syncrhonizedVariables.has(t.name)){const e=this.syncrhonizedVariables.get(t.name).value;infrastructureEventManager.sendEvent("updateValue",JSON.stringify({variableName:t.name,value:e}))}else this.syncrhonizedVariables.set(t.name,t)}updateValue(e){const t=e.variableName,o=e.value;this.syncrhonizedVariables.get(t).value!==o&&(this.syncrhonizedVariables.get(t).changeValueWithoutSync(o),infrastructureEventManager.sendEvent("updateValue",JSON.stringify({variableName:t,value:o})))}#l(){this.subscribe("create","standardObject",this.addStandardObject),this.subscribe("standardObject","valueChange",this.updateValue)}static types(){return{StandardObject:StandardObject}}}StandardObjectModel.register("StandardObjectModel");export{StandardObjectModel};class HologramRenderer{constructor(e,t){this.scene=e,this.utilityLayer=t}initializeElementManipulation(){this.boundingBox=BABYLON.BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox(this.mesh),this._sixDofDragBehavior=new BABYLON.SixDofDragBehavior,this._sixDofDragBehavior.dragDeltaRatio=1.2,this._sixDofDragBehavior.zDragFactor=1.2}renderImportedHologram(e){const t=e._meshFilePath,o=new BABYLON.Vector3(e._scaling._x,e._scaling._y,e._scaling._z),i=new BABYLON.Quaternion(e._rotation._x,e._rotation._y,e._rotation._z,e._rotation._w).toEulerAngles(),a=new BABYLON.Vector3(e._position._x,e._position._y,e._position._z),{stringSplit:n,directory:r}=this.#d(t);BABYLON.SceneLoader.LoadAssetContainer(r,n[n.length-1],this.scene,(t=>{try{t.addAllToScene(),t.meshes[0].rotationQuaternion=null,t.meshes[0].rotate(BABYLON.Axis.X,i.x),t.meshes[0].rotate(BABYLON.Axis.Y,i.y),t.meshes[0].rotate(BABYLON.Axis.Z,i.z),t.meshes[0].position=a,t.meshes[0].scaling=o,this.mesh=t.meshes[0],infrastructureEventManager.sendEvent("importedHologramCreated"+e.name,"")}catch(e){this.#e("ERROR "+e)}}))}renderStandardHologram(e){const t=e.name,o=new BABYLON.Quaternion(e._rotation._x,e._rotation._y,e._rotation._z,e._rotation._w).toEulerAngles(),i=new BABYLON.Vector3(e._position._x,e._position._y,e._position._z);this.#g(e,t),this.mesh.position=i,this.mesh.rotate(BABYLON.Axis.X,o.x),this.mesh.rotate(BABYLON.Axis.Y,o.y),this.mesh.rotate(BABYLON.Axis.Z,o.z),this.mesh.material.diffuseColor=BABYLON.Color3.FromHexString(e._color),infrastructureEventManager.sendEvent("standardHologramCreated"+e.name,"")}showOtherUserManipulation(){this._gizmo=new BABYLON.BoundingBoxGizmo(BABYLON.Color3.FromHexString("#FF0000"),this.utilityLayer),this._gizmo.rotationSphereSize=0,this._gizmo.scaleBoxSize=0,this._gizmo.attachedMesh=this.boundingBox}addHologramManipulator(){this._gizmo=new BABYLON.BoundingBoxGizmo(BABYLON.Color3.FromHexString("#FBFF00"),this.utilityLayer),this._gizmo.rotationSphereSize=.05,this._gizmo.scaleBoxSize=.05,this._gizmo.attachedMesh=this.boundingBox,this.boundingBox.addBehavior(this._sixDofDragBehavior)}removeHologramManipulator(){this._gizmo.attachedMesh=null,this._gizmo.dispose(),this._gizmo=null,this.boundingBox.removeBehavior(this._sixDofDragBehavior)}updatePositionDueManipulation(e){this.boundingBox.position=new BABYLON.Vector3(e._x,e._y,e._z)}updatePosition(e){null!==this.boundingBox?(this.#c(),this.mesh.position=new BABYLON.Vector3(e._x,e._y,e._z),this.boundingBox=BABYLON.BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox(this.mesh)):this.mesh.position=new BABYLON.Vector3(e._x,e._y,e._z)}updateRotation(e){const t=new BABYLON.Quaternion(e._x,e._y,e._z,e._w).toEulerAngles();this.mesh.rotate(BABYLON.Axis.X,t.x),this.mesh.rotate(BABYLON.Axis.Y,t.y),this.mesh.rotate(BABYLON.Axis.Z,t.z)}updateScalingDueManipulation(e){this.boundingBox.scaling=new BABYLON.Vector3(e._x,e._y,e._z)}updateScaling(e){null!==this.boundingBox?(this.#c(),this.mesh.scaling=new BABYLON.Vector3(e._x,e._y,e._z),this.boundingBox=BABYLON.BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox(this.mesh)):this.mesh.scaling=new BABYLON.Vector3(e._x,e._y,e._z)}updateColor(e){this.mesh.material.diffuseColor=BABYLON.Color3.FromHexString(e)}getHologramMesh(){return this.mesh}get sixDofDragBehavior(){return this._sixDofDragBehavior}get gizmo(){return this._gizmo}#c(){this.mesh.setParent(null),this.boundingBox.dispose()}#g(e,t){switch(e._shapeName){case StandardShape.Cube:this.mesh=BABYLON.MeshBuilder.CreateBox(t,e._creationOptions,this.scene);break;case StandardShape.Sphere:this.mesh=BABYLON.MeshBuilder.CreateSphere(t,e._creationOptions,this.scene);break;case StandardShape.Cylinder:this.mesh=BABYLON.MeshBuilder.CreateCylinder(t,e._creationOptions,this.scene);break;case StandardShape.Plane:this.mesh=BABYLON.MeshBuilder.CreatePlane(t,e._creationOptions,this.scene);break;case StandardShape.Disc:this.mesh=BABYLON.MeshBuilder.CreateDisc(t,e._creationOptions,this.scene);break;default:throw new Error("The required shape is not supported")}const o=new BABYLON.StandardMaterial("material",this.scene);o.diffuseColor=BABYLON.Color3.FromHexString(e._color),this.mesh.material=o}#d(e){const t=e.split("/");let o="";for(let e=0;e<t.length-1;e++)o+=t[e]+"/";return{stringSplit:t,directory:o}}#e(e){}}export{HologramRenderer};class SceneManager{constructor(){this._hologramRenders=new Map}initializeScene(){const e=document.getElementById("renderCanvas");this.#e("initialize scene called"),this.engine=new BABYLON.Engine(e,!0),this.scene=new BABYLON.Scene(this.engine),this.scene.clearColor=new BABYLON.Color3.Black;const t=new BABYLON.FreeCamera("camera1",new BABYLON.Vector3(0,1.3,-.3),this.scene);t.minZ=.01,t.attachControl(e,!0),t.inputs.addMouseWheel();new BABYLON.HemisphericLight("light",new BABYLON.Vector3(1,1,0)).intensity=1,this.utilityLayer=new BABYLON.UtilityLayerRenderer(this.scene),this.utilityLayer.utilityLayerScene.autoClearDepthAndStencil=!1,this._GUIManager=new BABYLON.GUI.GUI3DManager(this.scene),this.GUIManager.useRealisticScaling=!0}activateRenderLoop(){this.#e("activate render loop called"),this.#m().then((e=>{this.engine.runRenderLoop((()=>e.render()))}))}addStandardHologram(e){this.#e("addStandardHologram");const t=new HologramRenderer(this.scene,this.utilityLayer);t.renderStandardHologram(e),this.hologramRenders.set(e.name,t)}addImportedHologram(e){this.#e("addImportedHologram");const t=new HologramRenderer(this.scene,this.utilityLayer);t.renderImportedHologram(e),this.hologramRenders.set(e.name,t)}addNearMenu(e,t,o){const i=new BABYLON.GUI.NearMenu("NearMenu");let a=[];return i.rows=t,this.GUIManager.addControl(i),i.isPinned=!0,i.position=new BABYLON.Vector3(e._x,e._y,e._z),o.forEach((e=>{const t=new BABYLON.GUI.TouchHolographicButton;t.name=e._name,t.text=e._text,a.push(t),i.addButton(t)})),a}async#m(){let e;await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar")?(this.#e("IMMERSIVE AR SUPPORTED"),e=await this.scene.createDefaultXRExperienceAsync({uiOptions:{sessionMode:"immersive-ar",referenceSpaceType:"local-floor"}})):(this.#e("IMMERSIVE VR SUPPORTED"),e=await this.scene.createDefaultXRExperienceAsync({uiOptions:{sessionMode:"immersive-vr"}}));try{e.baseExperience.featuresManager.enableFeature(BABYLON.WebXRFeatureName.HAND_TRACKING,"latest",{xrInput:xr.input})}catch(e){this.#e("Articulated hand tracking not supported in this device.")}return this.scene}get hologramRenders(){return this._hologramRenders}get GUIManager(){return this._GUIManager}#e(e){}}export{SceneManager};class InfrastructureEventManager{constructor(){this.view=null}sendEvent(e,t){eventBus.emit(e,t)}setRootView(e){this.view=e}listenForCoreEvents(){eventBus.on("initialize",(()=>{this.#e("initialize scene"),this.view.initializeScene()})),eventBus.on("render",(()=>{this.#e("run render loop"),this.view.runRenderLoop()})),eventBus.on("createImportedHologram",(e=>{this.#e("create imported hologram"),this.view.notifyEventToModel("create","importedHologram",{view:this.view.viewId,hologram:JSON.parse(e)})})),eventBus.on("createStandardHologram",(e=>{this.#e("create standard hologram"),this.view.notifyEventToModel("create","standardHologram",{view:this.view.viewId,hologram:JSON.parse(e)})})),eventBus.on("createStandardObject",(e=>{this.#e("create standard object"),this.view.notifyEventToModel("create","standardObject",JSON.parse(e))})),eventBus.on("addManipulatorMenu",(e=>{this.#e("add manipulator menu");const t=JSON.parse(e),o=t.name,i=t.position;this.view.hologramView.addManipulatorMenu(o,i)})),eventBus.on("addNearMenu",(e=>{this.#e("add near menu");const t=JSON.parse(e),o=t._rows,i=t._position,a=t.buttonList;this.view.addNearMenu(o,i,a)})),eventBus.on("newAnimation",(e=>{this.#e("add animation"),this.view.notifyEventToModel("animation","createAnimation",JSON.parse(e))})),eventBus.on("stopAnimation",(e=>{this.#e("stop animation"),this.view.notifyEventToModel("animation","stopAnimation",JSON.parse(e))})),eventBus.on("valueChange",(e=>{this.view.notifyEventToModel("standardObject","valueChange",JSON.parse(e))})),eventBus.on("colorChange",(e=>{this.view.notifyEventToModel("updateHologram","changeColor",JSON.parse(e))})),eventBus.on("scalingChange",(e=>{this.view.notifyEventToModel("updateHologram","changeScaling",JSON.parse(e))})),eventBus.on("positionChange",(e=>{this.view.notifyEventToModel("updateHologram","changePosition",JSON.parse(e))})),eventBus.on("rotationChange",(e=>{this.view.notifyEventToModel("updateHologram","changeRotation",JSON.parse(e))}))}#e(e){}}const infrastructureEventManager=new InfrastructureEventManager;export{infrastructureEventManager};const MAX_EVENT_FOR_SECOND=20,REFERENCE_TIME_EVENT=1e3;class HologramView extends Croquet.View{constructor(e,t){super(e),this.model=e,this.sceneManager=t,this.hologramsManipulatorMenu=new Map,this.#u()}addManipulatorMenu(e,t){const o=new BABYLON.GUI.NearMenu("NearMenu");o.rows=1,this.sceneManager.GUIManager.addControl(o),o.isPinned=!0,this.sceneManager.hologramRenders.get(e).initializeElementManipulation(),o.parent=this.sceneManager.hologramRenders.get(e).getHologramMesh(),o.position=new BABYLON.Vector3(t._x,t._y,t._z);const i=new BABYLON.GUI.HolographicButton("manipulate",!1);o.addButton(i),this.#p(e,i),this.hologramsManipulatorMenu.set(e,new Triple(o,i))}showImportedHologram(e){this.sceneManager.addImportedHologram(this.model.holograms.get(e))}showStandardHologram(e){this.sceneManager.addStandardHologram(this.model.holograms.get(e))}showUserManipulation(e){this.#e("received show userManipulation "+e.hologramName);const t=e.hologramName;this.sceneManager.hologramRenders.get(t).showOtherUserManipulation()}showHologramUpdatedPosition(e){const t=this.model.holograms.get(e).position;this.sceneManager.hologramRenders.get(e).updatePosition(t)}showHologramUpdatedManipulatedPosition(e){const t=e.hologramName,o=new Vector3(e.bounding_box_position_x,e.bounding_box_position_y,e.bounding_box_position_z);this.sceneManager.hologramRenders.get(t).updatePositionDueManipulation(o)}showHologramUpdatedRotation(e){const t=this.model.holograms.get(e).rotation;this.sceneManager.hologramRenders.get(e).updateRotation(t)}showHologramUpdatedScaling(e){const t=this.model.holograms.get(e).scaling;this.sceneManager.hologramRenders.get(e).updateScaling(t)}showHologramUpdatedManipulatedScaling(e){const t=e.hologramName,o=new Vector3(e.bounding_box_scale_x,e.bounding_box_scale_y,e.bounding_box_scale_z);this.sceneManager.hologramRenders.get(t).updateScalingDueManipulation(o)}showHologramUpdatedColor(e){this.#e("received updateHologramColor"),this.sceneManager.hologramRenders.get(e).updateColor(this.model.holograms.get(e).color)}freezeControlButton(e){this.#e("received freezeControlButton hologram "+e.hologramName);const t=e.hologramName,o=this.hologramsManipulatorMenu.get(t);this.#v(o.y)}restoreControlButton(e){this.#e("received restore ControlButton hologram "+e.hologramName);const t=e.hologramName,o=this.hologramsManipulatorMenu.get(t);this.sceneManager.hologramRenders.get(t).removeHologramManipulator(),this.#p(e.hologramName,o.y)}clockEventTick(){this.timeElapsed=!0}showCurrentManipulation(){this.model.hologramInUserControl.forEach(((e,t)=>{this.sceneManager.hologramRenders.get(t).showOtherUserManipulation(),this.freezeControlButton({hologramName:t})}))}#v(e){e.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,e.frontMaterial.albedoColor=BABYLON.Color3.Red(),e.backMaterial.albedoColor=new BABYLON.Color3(.67,.29,.29),e.imageUrl="https://raw.githubusercontent.com/AnnaVitali/framework-collaborativeXR/master/img/IconClose.png",e.onPointerDownObservable.clear()}#w(e){this.#e("user start manipulating hologram "+e),this.publish("controlButton","clicked",{view:this.viewId,hologramName:e})}#M(e){this.#e("user stop manipulating"),this.publish("controlButton","released",{view:this.viewId,hologramName:e})}#p(e,t){t.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,t.frontMaterial.albedoColor=BABYLON.Color3.Blue(),t.backMaterial.albedoColor=new BABYLON.Color3(.29,.37,.67),t.text="Manipulate",t.imageUrl="https://raw.githubusercontent.com/AnnaVitali/framework-collaborativeXR/master/img/IconAdjust.png",t.onPointerDownObservable.clear(),t.onPointerDownObservable.add((()=>{this.#e("clicked"),this.#w(e);const o=this.sceneManager.hologramRenders.get(e);o.addHologramManipulator();let i=0;this.timeElapsed=!1;let a=!1;o.sixDofDragBehavior.onPositionChangedObservable.add((()=>{i+=1,a||(this.future(1e3).clockEventTick(),a=!0),i<20&&!this.timeElapsed?this.publish("hologramManipulation","positionChanged",this.#B(e,o)):this.timeElapsed&&(a=!1,this.timeElapsed=!1,i=0)})),o.gizmo.onScaleBoxDragObservable.add((()=>{this.publish("hologramManipulation","scaleChanged",this.#b(e,o))})),this.#_(e,t),this.publish("hologramManipulator","showUserManipulation",{view:this.viewId,hologramName:e})}))}#B(e,t){const o=t.boundingBox.absolutePosition,i=t.getHologramMesh().absolutePosition;return{hologramName:e,view:this.viewId,bounding_box_position_x:o.x,bounding_box_position_y:o.y,bounding_box_position_z:o.z,hologram_position_x:i.x,hologram_position_y:i.y,hologram_position_z:i.z}}#b(e,t){const o=t.boundingBox.absoluteScaling,i=t.getHologramMesh().absoluteScaling;return{hologramName:e,view:this.viewId,bounding_box_scale_x:o.x,bounding_box_scale_y:o.y,bounding_box_scale_z:o.z,hologram_scale_x:i.x,hologram_scale_y:i.y,hologram_scale_z:i.z}}#_(e,t){t.text="Stop manipulating",t.frontMaterial.alphaMode=BABYLON.Engine.ALPHA_ONEONE,t.frontMaterial.albedoColor=BABYLON.Color3.Green(),t.backMaterial.albedoColor=new BABYLON.Color3(.29,.67,.45),t.onPointerDownObservable.clear(),t.onPointerDownObservable.add((()=>{this.#M(e),this.sceneManager.hologramRenders.get(e).removeHologramManipulator(),this.#p(e,t)}))}#u(){this.subscribe(this.viewId,"freezeControlButton",this.freezeControlButton),this.subscribe(this.viewId,"restoreControlButton",this.restoreControlButton),this.subscribe(this.viewId,"showUserManipulation",this.showUserManipulation),this.subscribe(this.viewId,"showHologramUpdatedPosition",this.showHologramUpdatedManipulatedPosition),this.subscribe(this.viewId,"showHologramUpdatedScaling",this.showHologramUpdatedManipulatedScaling),this.subscribe(this.viewId,"showImportedHologram",this.showImportedHologram),this.subscribe(this.viewId,"showStandardHologram",this.showStandardHologram),this.subscribe("view","updateHologramColor",this.showHologramUpdatedColor),this.subscribe("view","updateHologramScaling",this.showHologramUpdatedScaling),this.subscribe("view","updateHologramPosition",this.showHologramUpdatedPosition),this.subscribe("view","updateHologramRotation",this.showHologramUpdatedRotation)}#e(e){}}export{HologramView};class RootView extends Croquet.View{constructor(e){super(e),this.model=e,this.sceneManager=new SceneManager,this.hologramView=new HologramView(this.model.hologramModel,this.sceneManager),infrastructureEventManager.setRootView(this),this.#S(),this.#u(),infrastructureEventManager.listenForCoreEvents()}initializeScene(){const e=document.createElement("canvas");e.setAttribute("id","renderCanvas"),e.setAttribute("style","width: 100%; height: 100%"),document.body.appendChild(e),this.sceneManager.initializeScene()}runRenderLoop(){this.hologramView.showCurrentManipulation(),this.sceneManager.activateRenderLoop()}notifyEventToModel(e,t,o){this.publish(e,t,o)}addNearMenu(e,t,o){this.sceneManager.addNearMenu(t,e,o).forEach((e=>{e.onPointerDownObservable.add((()=>{eventBus.emit(e.name,"")}))}))}propagateTick(e){infrastructureEventManager.sendEvent(e,"")}setElementUpdate(){this.#e("received setUpdate"),infrastructureEventManager.sendEvent("setUpdate","")}#S(){1===this.model.linkedViews.length&&(this.#e("set view in charge"),this.publish("view","viewInCharge",this.viewId),this.setElementUpdate())}#u(){this.subscribe(this.viewId,"setUpdate",this.setElementUpdate),this.subscribe("view","animationTick",this.propagateTick)}#e(e){}}export{RootView};class Quaternion{constructor(e,t,o,i){this._x=e,this._y=t,this._z=o,this._w=i}get x(){return this._x}get y(){return this._y}get z(){return this._z}get w(){return this._w}}export{Quaternion};class Triple{constructor(e,t,o){this._x=e,this._y=t,this._z=o}get x(){return this._x}get y(){return this._y}get z(){return this._z}}export{Triple};class Vector3{constructor(e,t,o){this._x=e,this._y=t,this._z=o}get x(){return this._x}get y(){return this._y}get z(){return this._z}}export{Vector3};